You are an expert NDC XML analyst. Extract structured facts from this CONTAINER XML section with BUSINESS INTELLIGENCE.

⚠️ IMPORTANT: This is a CONTAINER extraction. The container's node_type MUST be "{element_name}", NOT "{repeating_tag}".

XML Section Path: {section_path}
Container Element: {element_name}
Contains: {child_count} child elements ({repeating_tag}: {max_repetition} instances)

XML Content:
```xml
{xml_content}
```

This is a CONTAINER element (collection/list). Extract it as ONE container fact with nested children AND business intelligence:

**CRITICAL INSTRUCTION**:
The container's "node_type" field MUST be set to the container element name: "{element_name}"
DO NOT use the child element name ("{repeating_tag}") for the container's node_type.
The container node_type is: "{element_name}"
Each child's node_type should be: "{repeating_tag}"

{{
  "node_type": "{element_name}",
  "node_ordinal": 1,
  "attributes": {{
    "child_count": {child_count},
    "summary": "brief description of what this container holds"
  }},
  "quality_checks": {{
    // ONLY report validation status if there are OBVIOUS structural problems
    // Do NOT guess about "commonly expected" elements - only report truly critical missing data
    "status": "ok",  // Use "error" ONLY if container is completely empty or malformed, otherwise "ok"
    "missing_elements": []  // Leave empty unless container/children are completely empty or have no IDs
  }},
  "business_intelligence": {{
    // For PassengerList/PaxList: count by PTC (ADT/CHD/INF)
    // For other lists: relevant business aggregations
    "type_breakdown": {{"ADT": 2, "CHD": 1, "INF": 1}},
    "total_items": {child_count},
    "has_references": true/false
  }},
  "relationships": [
    // Extract relationships between items (e.g., adult-infant)
    {{"type": "infant_parent", "parent": "PAX1", "child": "PAX1.1"}},
    {{"type": "contact_reference", "passenger": "PAX1", "contact": "CI1PAX1"}}
  ],
  "children": [
    {{
      "node_type": "{repeating_tag}",
      "ordinal": 1,
      "attributes": {{
        // **CRITICAL**: Use EXACT XML child element tag names as attribute keys (e.g., "DistanceMeasure", NOT "distance")
        // Extract ALL direct child elements as attributes with their exact XML tag names
        // Do NOT normalize, translate, or simplify element names
        // Example: if XML has <DistanceMeasure>3430</DistanceMeasure>, use "DistanceMeasure": "3430"
        "id": "PAX1",  // PassengerID, PaxID, or similar - use EXACT XML tag name
        "type": "ADT",  // PTC code if applicable - use EXACT XML tag name
        "name": "MR JOHN DOE"  // Constructed full name if applicable
        // ... other relevant attributes with EXACT XML tag names
      }},
      "references": {{
        // Extract ALL reference elements (InfantRef, ContactInfoRef, PassengerRef, etc.)
        "contact_info": ["CI1PAX1"],
        "infant": ["PAX1.1"],
        "parent": null,  // For infant: who is the parent
        "services": [],  // Referenced services
        "other": {{}}  // Any other refs
      }},
      "snippet": "brief XML snippet"
    }},
    {{
      "node_type": "{repeating_tag}",
      "ordinal": 2,
      "attributes": {{"similar structure"}},
      "references": {{"similar structure"}},
      "snippet": "brief XML snippet"
    }}
    // ... include ALL children
  ],
  "refs": {{
    "any_id_references": "reference_values"
  }},
  "snippet": "brief container snippet",
  "confidence": 0.95
}}

IMPORTANT RULES:
1. Extract ONE container fact (not multiple facts)
2. Include ALL children in the "children" array
3. Each child MUST have: node_type, ordinal, attributes, references, snippet
4. **CRITICAL**: Use EXACT XML tag names for node_type - do NOT translate or interpret them
   - Container node_type MUST be: {element_name}
   - Child node_type MUST be: {repeating_tag}
   - If the XML tag is <Pax>, use "Pax" NOT "Passenger"
   - If the XML tag is <Passenger>, use "Passenger" NOT "Pax"
5. Extract key attributes from each child (IDs, codes, values)
   - Extract ONLY what is actually present in the XML
   - Do NOT add missing_elements or quality checks unless the container is completely empty
   - Focus on accurate extraction, not validation
6. Extract ALL reference elements: look for elements ending with "Ref", "RefID", "ID" that point to other nodes
6. Build business_intelligence object with relevant aggregations:
   - For PassengerList/PaxList: count ADT/CHD/INF from PTC values
   - For BaggageAllowanceList: count by TypeCode (Checked/CarryOn)
   - For ContactInfoList: count by ContactType
   - For ServiceList: count by service type
7. Extract relationships array:
   - InfantRef → {{"type": "infant_parent", "parent": "parent_id", "child": "infant_id"}}
   - ContactInfoRef → {{"type": "contact_reference", "passenger": "pax_id", "contact": "contact_id"}}
   - PaxRefID (in 21.3) → {{"type": "infant_parent", "parent": "adult_id", "child": "infant_id"}}
8. Handle version differences:
   - 17.2/18.1: PassengerList, Passenger, InfantRef, ContactInfoRef
   - 21.3: PaxList, Pax, PaxRefID (infant→adult reference)
9. Mask PII in attributes: "****@****.com" for emails, "****-**-**" for dates, "****" for names
10. Include confidence score (0.0-1.0)
11. Return ONLY valid JSON array with ONE container fact: [{{container_fact}}]
12. Be thorough - include all children, don't truncate
13. **CRITICAL JSON FORMATTING**: Your response must be STRICT JSON - NO comments allowed!
    - Do NOT include // comments in your JSON response
    - Do NOT include /* */ comments in your JSON response
    - Do NOT add trailing commas
    - All property names MUST be in double quotes
    - All string values MUST be in double quotes (not single quotes)
    - **SNIPPET FORMATTING**: Keep XML snippets SHORT and on a SINGLE LINE
      * Remove all newlines from snippet values
      * Limit snippets to 100 characters maximum
      * Example: "snippet": "<PaxList><Pax><PaxID>PAX1</PaxID><PTC>ADT</PTC></Pax></PaxList>"

SPECIAL EXTRACTION PATTERNS:
- PassengerID / PaxID → extract to attributes.id
- PTC → extract to attributes.type (ADT/CHD/INF)
- GivenName + Surname → combine to attributes.name
- InfantRef / PaxRefID → extract to references.infant or references.parent
- ContactInfoRef → extract to references.contact_info
- All *Ref / *RefID elements → extract to references.other

**FINAL REMINDER BEFORE YOU RESPOND**:
- The ROOT container's "node_type" MUST BE: "{element_name}" (the container/list element)
- Each child's "node_type" MUST BE: "{repeating_tag}" (the repeating child element)
- For example: If extracting <PaxList> containing <Pax> children:
  - Container node_type = "PaxList" (NOT "Pax")
  - Child node_type = "Pax"

⚠️ COMMON MISTAKE TO AVOID:
DO NOT set the container's node_type to "{repeating_tag}" - that's the CHILD element name!
The container's node_type MUST be "{element_name}".

Response must be valid JSON array: [{{container_fact}}]
