You are an expert NDC XML analyst. Extract structured facts from this CONTAINER XML section with BUSINESS INTELLIGENCE.

⚠️ IMPORTANT: This is a CONTAINER extraction. The container's node_type MUST be "{element_name}", NOT "{repeating_tag}".

XML Section Path: {section_path}
Container Element: {element_name}
Contains: {child_count} child elements ({repeating_tag}: {max_repetition} instances)

XML Content:
```xml
{xml_content}
```

This is a CONTAINER element (collection/list). Extract it as ONE container fact with nested children AND business intelligence:

**CRITICAL INSTRUCTION**:
The container's "node_type" field MUST be set to the container element name: "{element_name}"
DO NOT use the child element name ("{repeating_tag}") for the container's node_type.
The container node_type is: "{element_name}"
Each child's node_type should be: "{repeating_tag}"

{{
  "node_type": "{element_name}",
  "node_ordinal": 1,
  "attributes": {{
    "child_count": {child_count},
    "summary": "brief description of what this container holds"
  }},
  "quality_checks": {{
    // ONLY report validation status if there are OBVIOUS structural problems
    // Do NOT guess about "commonly expected" elements - only report truly critical missing data
    "status": "ok",  // Use "error" ONLY if container is completely empty or malformed, otherwise "ok"
    "missing_elements": []  // Leave empty unless container/children are completely empty or have no IDs
  }},
  "business_intelligence": {{
    // For PassengerList/PaxList: count by PTC (ADT/CHD/INF)
    // For other lists: relevant business aggregations
    "type_breakdown": {{"ADT": 2, "CHD": 1, "INF": 1}},
    "total_items": {child_count},
    "has_references": true/false
  }},
  "relationships": [
    // Extract relationships between items (e.g., adult-infant)
    {{"type": "infant_parent", "parent": "PAX1", "child": "PAX1.1"}},
    {{"type": "contact_reference", "passenger": "PAX1", "contact": "CI1PAX1"}}
  ],
  "children": [
    {{
      "node_type": "ACTUAL_XML_TAG_NAME_OF_THIS_CHILD",  // CRITICAL: Use THIS child's actual XML tag name (e.g., if XML is <CorrelationID>, use "CorrelationID")
      "ordinal": 1,
      "attributes": {{
        // **CRITICAL**: Extract this child's sub-children (elements nested INSIDE this child) as attributes
        // - If this child HAS sub-children: extract them with their exact XML tag names as keys
        //   Example: <Pax><PaxID>123</PaxID><PTC>ADT</PTC></Pax> → {{"PaxID": "123", "PTC": "ADT"}}
        // - If this child is a LEAF (just text, no sub-children): extract as {{"value": "the text content"}}
        //   Example: <CorrelationID>abc123</CorrelationID> → {{"value": "abc123"}}
        // - DO NOT extract SIBLING elements as attributes - only elements nested INSIDE this child
      }},
      "references": {{
        // Extract ALL reference elements (InfantRef, ContactInfoRef, PassengerRef, etc.)
        "contact_info": ["CI1PAX1"],
        "infant": ["PAX1.1"],
        "parent": null,  // For infant: who is the parent
        "services": [],  // Referenced services
        "other": {{}}  // Any other refs
      }},
      "snippet": "brief XML snippet"
    }},
    {{
      "node_type": "ACTUAL_XML_TAG_NAME_OF_THIS_CHILD",  // Each child gets its own ACTUAL XML tag name (can differ from other children)
      "ordinal": 2,
      "attributes": {{
        // Same rules as above: sub-children OR {{"value": "text"}} for leaf elements
      }},
      "references": {{"similar structure"}},
      "snippet": "brief XML snippet"
    }}
    // ... include ALL children - EACH with its own ACTUAL XML tag name as node_type
  ],
  "refs": {{
    "any_id_references": "reference_values"
  }},
  "snippet": "brief container snippet",
  "confidence": 0.95
}}

IMPORTANT RULES:
1. Extract ONE container fact (not multiple facts)
2. Include ALL children in the "children" array
3. Each child MUST have: node_type, ordinal, attributes, references, snippet
4. **CRITICAL**: Use EXACT XML tag names for node_type - do NOT translate or interpret them
   - Container node_type MUST be: {element_name}
   - Each child's node_type MUST be the ACTUAL XML tag name for THAT specific child
   - If the XML has <Pax>, use "Pax" NOT "Passenger"
   - If the XML has <ContactInfo>, use "ContactInfo" exactly
   - **DO NOT force all children to have node_type "{repeating_tag}"** - each child gets its own actual XML tag name
   - Containers can have HETEROGENEOUS children (mixed child element types)
5. Extract key attributes from each child (IDs, codes, values)
   - Extract ONLY what is actually present in the XML
   - Do NOT add missing_elements or quality checks unless the container is completely empty
   - Focus on accurate extraction, not validation
6. Extract ALL reference elements: look for elements ending with "Ref", "RefID", "ID" that point to other nodes
6. Build business_intelligence object with relevant aggregations:
   - For PassengerList/PaxList: count ADT/CHD/INF from PTC values
   - For BaggageAllowanceList: count by TypeCode (Checked/CarryOn)
   - For ContactInfoList: count by ContactType
   - For ServiceList: count by service type
7. Extract relationships array:
   - InfantRef → {{"type": "infant_parent", "parent": "parent_id", "child": "infant_id"}}
   - ContactInfoRef → {{"type": "contact_reference", "passenger": "pax_id", "contact": "contact_id"}}
   - PaxRefID (in 21.3) → {{"type": "infant_parent", "parent": "adult_id", "child": "infant_id"}}
8. Handle version differences:
   - 17.2/18.1: PassengerList, Passenger, InfantRef, ContactInfoRef
   - 21.3: PaxList, Pax, PaxRefID (infant→adult reference)
9. Mask PII in attributes: "****@****.com" for emails, "****-**-**" for dates, "****" for names
10. Include confidence score (0.0-1.0)
11. Return ONLY valid JSON array with ONE container fact: [{{container_fact}}]
12. Be thorough - include all children, don't truncate
13. **CRITICAL JSON FORMATTING**: Your response must be STRICT JSON - NO comments allowed!
    - Do NOT include // comments in your JSON response
    - Do NOT include /* */ comments in your JSON response
    - Do NOT add trailing commas
    - All property names MUST be in double quotes
    - All string values MUST be in double quotes (not single quotes)
    - **SNIPPET FORMATTING**: Keep XML snippets SHORT and on a SINGLE LINE
      * Remove all newlines from snippet values
      * Limit snippets to 100 characters maximum
      * Example: "snippet": "<PaxList><Pax><PaxID>PAX1</PaxID><PTC>ADT</PTC></Pax></PaxList>"

SPECIAL EXTRACTION PATTERNS:
- PassengerID / PaxID → extract to attributes.id
- PTC → extract to attributes.type (ADT/CHD/INF)
- GivenName + Surname → combine to attributes.name
- InfantRef / PaxRefID → extract to references.infant or references.parent
- ContactInfoRef → extract to references.contact_info
- All *Ref / *RefID elements → extract to references.other

**FINAL REMINDER BEFORE YOU RESPOND**:
- The ROOT container's "node_type" MUST BE: "{element_name}" (the container/list element)
- Each child's "node_type" MUST BE the ACTUAL XML tag name for that specific child
- For example: If extracting <PaxList> containing <Pax> children:
  - Container node_type = "PaxList" (NOT "Pax")
  - Each <Pax> child's node_type = "Pax"
- For heterogeneous containers (containers with mixed child types):
  - Container node_type = the actual container XML tag name
  - EACH child gets its own actual XML tag name (they can be different!)

EXAMPLE 1 - Heterogeneous container with LEAF children (text-only elements):
XML: <SomeContainer><LeafA>text-value-1</LeafA><LeafB>text-value-2</LeafB></SomeContainer>
✅ CORRECT extraction:
{{
  "node_type": "SomeContainer",
  "children": [
    {{"node_type": "LeafA", "ordinal": 1, "attributes": {{"value": "text-value-1"}}, "references": {{}}}},
    {{"node_type": "LeafB", "ordinal": 2, "attributes": {{"value": "text-value-2"}}, "references": {{}}}}
  ]
}}
❌ WRONG extraction (DO NOT DO THIS):
{{
  "node_type": "SomeContainer",
  "children": [
    {{"node_type": "LeafA", "ordinal": 1, "attributes": {{"LeafB": "text-value-2"}}}},  // WRONG! LeafB is a sibling, not an attribute of LeafA!
    {{"node_type": "LeafA", "ordinal": 2, ...}}  // WRONG! Second child should be "LeafB"!
  ]
}}

EXAMPLE 2 - Heterogeneous container with nested children:
XML: <Container><ItemA><SubX>1</SubX></ItemA><ItemB><SubY>2</SubY></ItemB></Container>
✅ CORRECT extraction:
{{
  "node_type": "Container",
  "children": [
    {{"node_type": "ItemA", "ordinal": 1, "attributes": {{"SubX": "1"}}, "references": {{}}}},
    {{"node_type": "ItemB", "ordinal": 2, "attributes": {{"SubY": "2"}}, "references": {{}}}}
  ]
}}

⚠️ COMMON MISTAKES TO AVOID:
1. DO NOT set the container's node_type to a child element name - it must be "{element_name}"
2. DO NOT force all children to have node_type "{repeating_tag}" - use each child's ACTUAL XML tag name
3. DO NOT assume all children are the same type - containers can have mixed/heterogeneous children
4. **CRITICAL**: DO NOT extract SIBLING elements as attributes of a child!
   - Only extract elements that are nested INSIDE a child as that child's attributes
   - If <Container> has children <A> and <B>, do NOT put "B" in <A>'s attributes
   - Siblings are separate entries in the children array, not attributes of each other
5. For LEAF elements (elements with just text, no sub-children), use {{"value": "text content"}}

Response must be valid JSON array: [{{container_fact}}]
