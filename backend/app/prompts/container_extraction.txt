You are an expert NDC XML analyst. Extract structured facts from this CONTAINER XML section with BUSINESS INTELLIGENCE.

âš ï¸ IMPORTANT: This is a CONTAINER extraction. The container's node_type MUST be "{element_name}", NOT "{repeating_tag}".

XML Section Path: {section_path}
Container Element: {element_name}
Contains: {child_count} child elements ({repeating_tag}: {max_repetition} instances)

XML Content:
```xml
{xml_content}
```

This is a CONTAINER element (collection/list). Extract it as ONE container fact with nested children AND business intelligence:

**CRITICAL INSTRUCTION**:
The container's "node_type" field MUST be set to the container element name: "{element_name}"
DO NOT use the child element name ("{repeating_tag}") for the container's node_type.
The container node_type is: "{element_name}"
Each child's node_type should be: "{repeating_tag}"

{{
  "node_type": "{element_name}",
  "node_ordinal": 1,
  "attributes": {{
    "child_count": {child_count},
    "summary": "brief description of what this container holds"
  }},
  "quality_checks": {{
    // ONLY report validation status if there are OBVIOUS structural problems
    // Do NOT guess about "commonly expected" elements - only report truly critical missing data
    "status": "ok",  // Use "error" ONLY if container is completely empty or malformed, otherwise "ok"
    "missing_elements": []  // Leave empty unless container/children are completely empty or have no IDs
  }},
  "business_intelligence": {{
    // For PassengerList/PaxList: count by PTC (ADT/CHD/INF)
    // For other lists: relevant business aggregations
    "type_breakdown": {{"ADT": 2, "CHD": 1, "INF": 1}},
    "total_items": {child_count},
    "has_references": true/false
  }},
  "relationships": [
    // Extract relationships between items (e.g., adult-infant)
    {{"type": "infant_parent", "parent": "PAX1", "child": "PAX1.1"}},
    {{"type": "contact_reference", "passenger": "PAX1", "contact": "CI1PAX1"}}
  ],
  "children": [
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // âš ï¸âš ï¸âš ï¸ ABSOLUTELY CRITICAL - READ THIS BEFORE EXTRACTING CHILDREN âš ï¸âš ï¸âš ï¸
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //
    // DO NOT FLATTEN NESTED STRUCTURES!
    //
    // If you see: <Pax><Individual><Birthdate>...</Birthdate><GivenName>...</GivenName></Individual></Pax>
    //
    // âŒ WRONG: Extract as Pax attributes: {{"birthdate": "...", "name": "..."}}
    // âœ… CORRECT: Extract Individual as nested child in Pax's children array
    //
    // Rule: If an element contains OTHER ELEMENTS (not just text), it MUST be extracted
    // as a nested child, NOT flattened into attributes!
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    {{
      "node_type": "ACTUAL_XML_TAG_NAME_OF_THIS_CHILD",  // CRITICAL: Use THIS child's actual XML tag name (e.g., if XML is <CorrelationID>, use "CorrelationID")
      "ordinal": 1,
      "attributes": {{
        // âš ï¸ CRITICAL EXTRACTION RULES - READ CAREFULLY âš ï¸:
        //
        // RULE 1: SIMPLE LEAF ELEMENTS (text-only, no nested children)
        //    âœ… Extract these as attributes
        //    Example: <Pax><PaxID>123</PaxID><PTC>ADT</PTC></Pax>
        //    Result: {{"PaxID": "123", "PTC": "ADT"}}
        //
        // RULE 2: STRUCTURED NESTED ELEMENTS (contain other elements, not just text)
        //    âŒ DO NOT extract as attributes
        //    âŒ DO NOT flatten
        //    âŒ DO NOT combine fields
        //    âœ… Extract as nested children in "children" array (see below)
        //
        //    Example of STRUCTURED element:
        //    <Pax>
        //      <Individual>             â† This is STRUCTURED (has children)
        //        <Birthdate>...</Birthdate>
        //        <GivenName>...</GivenName>
        //      </Individual>
        //      <PaxID>123</PaxID>       â† This is LEAF (just text)
        //    </Pax>
        //
        //    âŒ WRONG (flattened):
        //    {{"PaxID": "123", "birthdate": "...", "name": "..."}}
        //
        //    âœ… CORRECT (preserved structure):
        //    {{"PaxID": "123"}}, with Individual in children array below
        //
        // RULE 3: How to distinguish LEAF vs STRUCTURED:
        //    - LEAF: Element contains ONLY TEXT (no child elements)
        //    - STRUCTURED: Element contains OTHER ELEMENTS (has child tags inside)
        //
        // RULE 4: DO NOT extract SIBLING elements as attributes
        //    - Only extract elements nested INSIDE this child
        //
        // For this child: extract ONLY simple leaf elements as attributes
      }},
      "children": [
        // **NEW**: If this child contains STRUCTURED nested elements (elements with their own children),
        // extract them here as nested children, NOT as attributes above
        // Example: <Pax><Individual><Birthdate>...</Birthdate></Individual></Pax>
        // â†’ Individual should appear here in Pax's children array
      ],
      "references": {{
        // Extract ALL reference elements (InfantRef, ContactInfoRef, PassengerRef, etc.)
        "contact_info": ["CI1PAX1"],
        "infant": ["PAX1.1"],
        "parent": null,  // For infant: who is the parent
        "services": [],  // Referenced services
        "other": {{}}  // Any other refs
      }},
      "snippet": "brief XML snippet"
    }},
    {{
      "node_type": "ACTUAL_XML_TAG_NAME_OF_THIS_CHILD",  // Each child gets its own ACTUAL XML tag name (can differ from other children)
      "ordinal": 2,
      "attributes": {{
        // SAME CRITICAL RULES APPLY:
        // - Extract ONLY leaf elements (text-only) as attributes
        // - DO NOT flatten structured nested elements
        // - DO NOT combine fields from nested structures
        // - Structured elements go in "children" array below
      }},
      "children": [
        // If this child has STRUCTURED nested elements, extract them here
      ],
      "references": {{"similar structure"}},
      "snippet": "brief XML snippet"
    }}
    // ... include ALL children - EACH with its own ACTUAL XML tag name as node_type
  ],
  "refs": {{
    "any_id_references": "reference_values"
  }},
  "snippet": "brief container snippet",
  "confidence": 0.95
}}

IMPORTANT RULES:
1. Extract ONE container fact (not multiple facts)
2. Include ALL children in the "children" array
3. Each child MUST have: node_type, ordinal, attributes, references, snippet
4. **CRITICAL**: Use EXACT XML tag names for node_type - do NOT translate or interpret them
   - Container node_type MUST be: {element_name}
   - Each child's node_type MUST be the ACTUAL XML tag name for THAT specific child
   - If the XML has <Pax>, use "Pax" NOT "Passenger"
   - If the XML has <ContactInfo>, use "ContactInfo" exactly
   - **DO NOT force all children to have node_type "{repeating_tag}"** - each child gets its own actual XML tag name
   - Containers can have HETEROGENEOUS children (mixed child element types)
5. Extract key attributes from each child (IDs, codes, values)
   - Extract ONLY what is actually present in the XML
   - Do NOT add missing_elements or quality checks unless the container is completely empty
   - Focus on accurate extraction, not validation
6. Extract ALL reference elements: look for elements ending with "Ref", "RefID", "ID" that point to other nodes
6. Build business_intelligence object with relevant aggregations:
   - For PassengerList/PaxList: count ADT/CHD/INF from PTC values
   - For BaggageAllowanceList: count by TypeCode (Checked/CarryOn)
   - For ContactInfoList: count by ContactType
   - For ServiceList: count by service type
7. Extract relationships array:
   - InfantRef â†’ {{"type": "infant_parent", "parent": "parent_id", "child": "infant_id"}}
   - ContactInfoRef â†’ {{"type": "contact_reference", "passenger": "pax_id", "contact": "contact_id"}}
   - PaxRefID (in 21.3) â†’ {{"type": "infant_parent", "parent": "adult_id", "child": "infant_id"}}
8. Handle version differences:
   - 17.2/18.1: PassengerList, Passenger, InfantRef, ContactInfoRef
   - 21.3: PaxList, Pax, PaxRefID (infantâ†’adult reference)
9. Mask PII in attributes: "****@****.com" for emails, "****-**-**" for dates, "****" for GivenName/Surname fields
   - DO NOT combine GivenName + Surname - keep them separate or in nested structure
10. Include confidence score (0.0-1.0)
11. Return ONLY valid JSON array with ONE container fact: [{{container_fact}}]
12. Be thorough - include all children, don't truncate
13. **CRITICAL JSON FORMATTING**: Your response must be STRICT JSON - NO comments allowed!
    - Do NOT include // comments in your JSON response
    - Do NOT include /* */ comments in your JSON response
    - Do NOT add trailing commas
    - All property names MUST be in double quotes
    - All string values MUST be in double quotes (not single quotes)
    - **SNIPPET FORMATTING**: Keep XML snippets SHORT and on a SINGLE LINE
      * Remove all newlines from snippet values
      * Limit snippets to 100 characters maximum
      * Example: "snippet": "<PaxList><Pax><PaxID>PAX1</PaxID><PTC>ADT</PTC></Pax></PaxList>"

SPECIAL EXTRACTION PATTERNS:
- PassengerID / PaxID â†’ extract to attributes (keep exact XML tag name)
- PTC â†’ extract to attributes (keep exact XML tag name)
- **CRITICAL - READ CAREFULLY**: Individual/Birthdate/GivenName/Surname handling:
  * If you see <Pax><Individual><Birthdate>...<GivenName>...<Surname>...</Individual></Pax>:
    âœ… CORRECT: Individual is a NESTED CHILD in Pax's children array
    âœ… Individual has attributes: {{"Birthdate": "...", "GivenName": "...", "Surname": "..."}}
    âŒ WRONG: DO NOT extract {{"birthdate": "...", "name": "..."}} as Pax attributes
    âŒ WRONG: DO NOT combine GivenName + Surname into a single "name" field
    âŒ WRONG: DO NOT flatten Individual's children into Pax's attributes
  * If GivenName/Surname are DIRECT children of Pax (no Individual wrapper):
    â†’ Extract as individual Pax attributes: {{"GivenName": "...", "Surname": "..."}}
    â†’ Still DO NOT combine them!
- InfantRef / PaxRefID â†’ extract to references.infant or references.parent
- ContactInfoRef â†’ extract to references.contact_info
- All *Ref / *RefID elements â†’ extract to references.other

**FINAL REMINDER BEFORE YOU RESPOND**:
- The ROOT container's "node_type" MUST BE: "{element_name}" (the container/list element)
- Each child's "node_type" MUST BE the ACTUAL XML tag name for that specific child
- For example: If extracting <PaxList> containing <Pax> children:
  - Container node_type = "PaxList" (NOT "Pax")
  - Each <Pax> child's node_type = "Pax"
- For heterogeneous containers (containers with mixed child types):
  - Container node_type = the actual container XML tag name
  - EACH child gets its own actual XML tag name (they can be different!)

EXAMPLE 1 - Heterogeneous container with LEAF children (text-only elements):
XML: <SomeContainer><LeafA>text-value-1</LeafA><LeafB>text-value-2</LeafB></SomeContainer>
âœ… CORRECT extraction:
{{
  "node_type": "SomeContainer",
  "children": [
    {{"node_type": "LeafA", "ordinal": 1, "attributes": {{"value": "text-value-1"}}, "references": {{}}}},
    {{"node_type": "LeafB", "ordinal": 2, "attributes": {{"value": "text-value-2"}}, "references": {{}}}}
  ]
}}
âŒ WRONG extraction (DO NOT DO THIS):
{{
  "node_type": "SomeContainer",
  "children": [
    {{"node_type": "LeafA", "ordinal": 1, "attributes": {{"LeafB": "text-value-2"}}}},  // WRONG! LeafB is a sibling, not an attribute of LeafA!
    {{"node_type": "LeafA", "ordinal": 2, ...}}  // WRONG! Second child should be "LeafB"!
  ]
}}

EXAMPLE 2 - Heterogeneous container with nested children:
XML: <Container><ItemA><SubX>1</SubX></ItemA><ItemB><SubY>2</SubY></ItemB></Container>
âœ… CORRECT extraction:
{{
  "node_type": "Container",
  "children": [
    {{"node_type": "ItemA", "ordinal": 1, "attributes": {{"SubX": "1"}}, "references": {{}}}},
    {{"node_type": "ItemB", "ordinal": 2, "attributes": {{"SubY": "2"}}, "references": {{}}}}
  ]
}}

EXAMPLE 3 - Pax with nested Individual structure (CRITICAL - DO NOT FLATTEN):
XML:
<PaxList>
  <Pax>
    <Individual>
      <Birthdate>1980-01-01</Birthdate>
      <GivenName>JOHN</GivenName>
      <Surname>DOE</Surname>
    </Individual>
    <PaxID>PAX1</PaxID>
    <PTC>ADT</PTC>
  </Pax>
</PaxList>

âœ… CORRECT extraction (preserve Individual as nested child):
{{
  "node_type": "PaxList",
  "children": [
    {{
      "node_type": "Pax",
      "ordinal": 1,
      "attributes": {{
        "PaxID": "PAX1",
        "PTC": "ADT"
      }},
      "children": [
        {{
          "node_type": "Individual",
          "ordinal": 1,
          "attributes": {{
            "Birthdate": "1980-01-01",
            "GivenName": "JOHN",
            "Surname": "DOE"
          }},
          "references": {{}}
        }}
      ],
      "references": {{}}
    }}
  ]
}}

âŒ WRONG extraction (DO NOT flatten Individual):
{{
  "node_type": "PaxList",
  "children": [
    {{
      "node_type": "Pax",
      "ordinal": 1,
      "attributes": {{
        "PaxID": "PAX1",
        "PTC": "ADT",
        "birthdate": "1980-01-01",  // âŒ WRONG! Flattened from Individual/Birthdate
        "name": "JOHN DOE"           // âŒ WRONG! Flattened and combined from Individual/GivenName+Surname
      }},
      "references": {{}}
    }}
  ]
}}

âš ï¸ COMMON MISTAKES TO AVOID:
1. DO NOT set the container's node_type to a child element name - it must be "{element_name}"
2. DO NOT force all children to have node_type "{repeating_tag}" - use each child's ACTUAL XML tag name
3. DO NOT assume all children are the same type - containers can have mixed/heterogeneous children
4. **CRITICAL**: DO NOT extract SIBLING elements as attributes of a child!
   - Only extract elements that are nested INSIDE a child as that child's attributes
   - If <Container> has children <A> and <B>, do NOT put "B" in <A>'s attributes
   - Siblings are separate entries in the children array, not attributes of each other
5. **CRITICAL**: DO NOT FLATTEN structured nested elements into attributes!
   - If an element contains OTHER ELEMENTS (not just text), it's a STRUCTURED element
   - Extract structured elements as nested children in the "children" array, NOT as flattened attributes
   - Example: <Pax><Individual><Birthdate>...</Birthdate></Individual></Pax>
     â†’ "Individual" is structured (has child elements), so keep it as a nested child
     â†’ DO NOT flatten to attributes: {{"birthdate": "..."}}
   - Only flatten LEAF elements (text-only, no nested children) into attributes
6. For LEAF elements (elements with just text, no sub-children), use {{"value": "text content"}}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸš¨ğŸš¨ğŸš¨ FINAL CHECK BEFORE RESPONDING - NESTED STRUCTURE VERIFICATION ğŸš¨ğŸš¨ğŸš¨
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Before you output your JSON response, verify:

1. Did you check if ANY child contains NESTED ELEMENTS (elements with child tags)?
2. For EACH nested element found:
   âœ… Is it in the "children" array (NOT in "attributes")?
   âœ… Does it have its own "node_type" matching the XML tag name?
   âœ… Does it have its own "attributes" with the nested leaf values?

3. Specifically for Pax/Individual:
   â“ Does the XML have <Pax><Individual>...?
   âœ… If YES: Pax MUST have a "children" array containing Individual
   âœ… Individual node_type = "Individual"
   âœ… Individual attributes = {{"Birthdate": "...", "GivenName": "...", "Surname": "..."}}
   âŒ Pax attributes should NOT contain birthdate, name, or any Individual fields

4. If you extracted ANY of these as Pax attributes, YOU MADE A MISTAKE:
   âŒ "birthdate" (this belongs in Individual, not Pax)
   âŒ "name" (this belongs in Individual as GivenName + Surname, not combined)
   âŒ Any field that came from a NESTED element

DOUBLE-CHECK YOUR JSON NOW before responding!
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Response must be valid JSON array: [{{container_fact}}]
